<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Search Visualization ‚Äî DLS, IDDFS, DFS, BFS, UCS, Bidirectional</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<style>
body {background:#f8fafc; color:#0f172a; padding:20px;}
.panel {background:#fff; padding:20px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.1); margin-bottom:20px;}
.steps {height:200px; overflow-y:auto; background:#f1f5f9; padding:10px; border-radius:8px;}
.node-rect {stroke:#333;stroke-width:1;}
.unvisited {fill:#eef2ff;}
.visited {fill:#fde68a;}
.found {fill:#bbf7d0;}
.svg-container {overflow:visible; display:flex; justify-content:center;}
svg {background:#fff; border-radius:12px; display:block;}
.student-list {display:flex; flex-wrap:wrap; gap:8px;}
.student-list .student {background:#eef2ff; padding:6px 10px; border-radius:6px; font-size:13px;}
.small-muted {font-size:13px; color:#65748a;}
.badge-result {font-size:14px; padding:8px 10px;}
</style>
</head>
<body>
<div class="container-fluid">
  <h2 class="mb-4">Search Visualization ‚Äî DLS, IDDFS, DFS, BFS, UCS, Bidirectional</h2>

  <div class="panel mb-3">
    <div class="row g-3 align-items-end">
      <div class="col-md-2">
        <label class="form-label">Algorithm</label>
        <select id="alg" class="form-select">
          <option>DLS</option>
          <option>IDDFS</option>
          <option>DFS</option>
          <option>BFS</option>
          <option>UCS</option>
          <option>Bidirectional</option>
        </select>
      </div>
      <div class="col-md-3">
        <label class="form-label">Search Student</label>
        <input id="query" type="text" class="form-control" placeholder="Student 1">
      </div>
      <div class="col-md-2">
        <label class="form-label">Depth / MaxDepth</label>
        <input id="limit" type="number" class="form-control" value="4">
      </div>
      <div class="col-md-2">
        <label class="form-label">Speed (ms)</label>
        <input id="speed" type="number" class="form-control" value="300">
      </div>
      <div class="col-md-3 d-flex gap-2">
        <button id="startBtn" class="btn btn-primary" onclick="startSearch()">Start Search</button>
        <button class="btn btn-secondary" onclick="resetTree()">Reset</button>
      </div>
    </div>
  </div>

  <div class="panel mb-3 svg-container">
    <svg id="treeSvg"></svg>
  </div>

  <div class="panel mb-3">
    <strong>üìñ What Happened ‚Äî Step-by-Step Explanation:</strong>
    <div id="explanation" class="mt-2 p-3 bg-light rounded" style="min-height:60px;">
      <span class="text-muted">Run a search to see a detailed explanation of what the algorithm did!</span>
    </div>
  </div>
  <div class="panel mb-3">
    <strong>Time & Space Complexity:</strong>
    <div id="complexity" class="mt-2 small-muted"></div>
  </div>

  <div class="panel">
    <strong>All Students:</strong>
    <div id="allStudents" class="student-list mt-2"></div>
  </div>
  <div class="panel mb-3">
    <div class="d-flex justify-content-between align-items-center">
      <strong>Traversal Steps:</strong>
      <div class="d-flex align-items-center gap-3">
        <span id="resultBadge" class="badge badge-result d-none"></span>
        <strong>Steps Count: <span id="stepsCount">0</span></strong>
      </div>
    </div>
    <div id="log" class="steps mt-2"></div>
  </div>



</div>

<script>
// global flag to control cost visibility
window.showCosts = false;

// ---------- Tree (with simple edge costs for UCS demo) ----------
function createTree() {
  const root = {label:'University', children:[], cost:0};
  let id = 1;
  function randCost(){ return Math.floor(Math.random()*4)+1; } // cost 1-4
  for(let c=1;c<=3;c++){
    const cls = {label:'Classroom '+String.fromCharCode(64+c), children:[], cost: randCost()};
    for(let l1=0;l1<2;l1++){
      const l1Node = {label:'Student '+id++, children:[], cost: randCost()};
      for(let l2=0;l2<2;l2++){
        const l2Node = {label:'Student '+id++, children:[], cost: randCost()};
        for(let l3=0;l3<2;l3++){
          l2Node.children.push({label:'Student '+id++, children:[], cost: randCost()});
        }
        l1Node.children.push(l2Node);
      }
      cls.children.push(l1Node);
    }
    root.children.push(cls);
  }
  return root;
}

const tree = createTree();
const svg = document.getElementById('treeSvg');
const coords = new Map();

// ---------- Layout ----------
function layoutTree(root) {
  const levels = [];
  function walk(node, depth) {
    if (!levels[depth]) levels[depth] = [];
    levels[depth].push(node);
    node.children.forEach(c => walk(c, depth + 1));
  }
  walk(root, 0);

  const maxDepth = levels.length - 1;
  const maxNodesInLevel = Math.max(...levels.map(l => l.length));

  const nodeW = 110, nodeH = 30, hGap = 40, vGap = 8;
  const W = (maxDepth + 1) * (nodeW + hGap) + 100;
  const H = Math.max(400, maxNodesInLevel * (nodeH + vGap) + 80);

  svg.setAttribute('width', W);
  svg.setAttribute('height', H);

  levels.forEach((nodes, depth) => {
    const x = 60 + depth * (nodeW + hGap);
    const totalHeight = nodes.length * (nodeH + vGap);
    const startY = (H - totalHeight) / 2 + nodeH / 2;

    nodes.forEach((n, i) => {
      coords.set(n, { x: x, y: startY + i * (nodeH + vGap) });
    });
  });
}

layoutTree(tree);

// ---------- Draw ----------
function drawTree(highlight=null,found=null, extraText=null) {
  svg.innerHTML='';
  // lines
  coords.forEach((pos,node)=>{
    node.children.forEach(c=>{
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      const p=pos,q=coords.get(c);
      line.setAttribute('x1',p.x+45); line.setAttribute('y1',p.y);
      line.setAttribute('x2',q.x-45); line.setAttribute('y2',q.y);
      line.setAttribute('stroke','#cbd5e1'); line.setAttribute('stroke-width',2);
      svg.appendChild(line);
      // show edge cost midpoint for UCS visualization
      if(typeof c.cost !== 'undefined'){
        const midx=(p.x+45 + q.x-45)/2;
        const midy=(p.y + q.y)/2;
        if(window.showCosts){
        const t=document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x',midx); t.setAttribute('y',midy-6);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','10');
        t.textContent='cost:'+c.cost;
        svg.appendChild(t);
        }

      }
    });
  });
  // nodes
  coords.forEach((pos,node)=>{
    const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x',pos.x-45); rect.setAttribute('y',pos.y-15);
    rect.setAttribute('width',90); rect.setAttribute('height',30); rect.setAttribute('rx',6);
    if(node===found) rect.setAttribute('class','node-rect found');
    else if(highlight===node) rect.setAttribute('class','node-rect visited');
    else rect.setAttribute('class','node-rect unvisited');
    svg.appendChild(rect);
    const text=document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x',pos.x); text.setAttribute('y',pos.y+5);
    text.setAttribute('text-anchor','middle'); text.setAttribute('font-size','11');
    text.textContent=node.label;
    svg.appendChild(text);
    // small cost badge inside node (cost from parent)
    if(node.cost){
      if(window.showCosts){
      const costT=document.createElementNS('http://www.w3.org/2000/svg','text');
      costT.setAttribute('x',pos.x+30); costT.setAttribute('y',pos.y-8);
      costT.setAttribute('text-anchor','middle'); costT.setAttribute('font-size','10');
      costT.setAttribute('fill','#475569');
      costT.textContent='('+node.cost+')';
      svg.appendChild(costT);
      }

    }
  });
  if(extraText){
    const info=document.createElementNS('http://www.w3.org/2000/svg','text');
    info.setAttribute('x',20); info.setAttribute('y',20);
    info.setAttribute('font-size','13'); info.setAttribute('fill','#0f172a');
    info.textContent=extraText;
    svg.appendChild(info);
  }
}

// ---------- Utility ----------
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
const speedInput=document.getElementById('speed');
let speed=parseInt(speedInput.value);
speedInput.addEventListener('change',()=>{speed=parseInt(speedInput.value);});

// find node by label (exact match, case-insensitive)
function findNodeByLabel(root,label){
  let found=null;
  function walk(n){
    if(n.label.toLowerCase()===label.toLowerCase()){ found=n; return; }
    for(const c of n.children){ if(found) return; walk(c); }
  }
  walk(root);
  return found;
}

// collect all nodes in tree (preorder)
function collectAll(root){
  const arr=[];
  function walk(n){ arr.push(n); n.children.forEach(c=>walk(c)); }
  walk(root); return arr;
}

// ---------- DLS & IDDFS (existing behavior) ----------
async function DLS(node,target,limit,steps=[],depth=0,trace=[]) {
  steps.push(node);
  trace.push({node:node.label, depth:depth, limit:limit, action:'visit'});
  drawTree(node,null); 
  await sleep(speed);
  if(node.label.toLowerCase().includes(target.toLowerCase())) {
    trace.push({node:node.label, depth:depth, limit:limit, action:'found'});
    return {found:node, trace:trace};
  }
  if(limit<=0) {
    trace.push({node:node.label, depth:depth, limit:limit, action:'limit_reached'});
    return {found:null, trace:trace};
  }
  for(const c of node.children){
    trace.push({node:node.label, depth:depth, action:'explore_child', child:c.label});
    const res=await DLS(c,target,limit-1,steps,depth+1,trace);
    if(res.found) return res;
  }
  trace.push({node:node.label, depth:depth, action:'backtrack'});
  return {found:null, trace:trace};
}

async function IDDFS(root,target,maxDepth,steps=[]) {
  let allTraces=[];
  for(let depth=0;depth<=maxDepth;depth++){
    const res=await DLS(root,target,depth,steps,0,[]);
    allTraces.push({depthLimit:depth, trace:res.trace});
    if(res.found) return {found:res.found, allTraces:allTraces, finalDepth:depth};
  }
  return {found:null, allTraces:allTraces, finalDepth:maxDepth};
}

// ---------- DFS (unlimited) ----------
async function DFS_CollectOrder(root,target){
  const trace=[];
  const visited=[];
  async function dfs(node,depth=0){
    visited.push(node);
    trace.push({node:node.label, action:'visit', depth});
    // we'll not animate inside recursive calls to keep consistent; animation handled after order collected
    for(const c of node.children){
      await dfs(c, depth+1);
    }
  }
  await dfs(root,0);
  return visited;
}

// ---------- BFS ----------
function BFS_Order(root, target){
  const q=[root];
  const visited=[];
  while(q.length){
    const n=q.shift();
    visited.push(n);
    for(const c of n.children) q.push(c);
  }
  return visited;
}

// ---------- DFS (iterative stack, STOPS when target found) ----------
function DFS_Order(root, targetLabel) {
  const stack = [root];
  const visited = [];
  const lowerTarget = targetLabel.toLowerCase();

  while (stack.length) {
    const n = stack.pop();
    visited.push(n);

    // STOP IMMEDIATELY when target is found
    if (n.label.toLowerCase() === lowerTarget) {
      return visited;   // return only the nodes visited up to this point
    }

    // push children in reverse order to maintain left-to-right order
    for (let i = n.children.length - 1; i >= 0; i--) {
      stack.push(n.children[i]);
    }
  }

  return visited; // target not found
}


// ---------- UCS (priority queue by cumulative cost) ----------
function UCS_Order(root,target){
  // Use array as simple priority queue (small tree)
  const pq=[{node:root,cost:0, path:[root]}];
  const visitedSet=new Set();
  const visitedOrder=[];
  while(pq.length){
    // extract min
    pq.sort((a,b)=>a.cost-b.cost);
    const cur=pq.shift();
    const n=cur.node;
    if(visitedSet.has(n)) continue;
    visitedSet.add(n);
    visitedOrder.push({node:n, cost:cur.cost, path:cur.path});
    // push children
    for(const c of n.children){
      const newCost = cur.cost + (c.cost||1);
      pq.push({node:c, cost:newCost, path: cur.path.concat([c])});
    }
  }
  return visitedOrder;
}

// ---------- Bidirectional (BFS from both sides) ----------
function Bidirectional_Order(root,targetLabel){
  // find target node object
  const target = findNodeByLabel(root, targetLabel);
  if(!target) return {found:false, message:'Target not present in tree', orderFromStart:[], orderFromGoal:[]};
  const q1=[root], q2=[target];
  const vis1=new Set([root]), vis2=new Set([target]);
  const parent1=new Map(), parent2=new Map();
  const order1=[], order2=[];
  while(q1.length && q2.length){
    // one step from start
    const n1=q1.shift(); order1.push(n1);
    for(const c of n1.children){
      if(!vis1.has(c)){ vis1.add(c); parent1.set(c,n1); q1.push(c); }
    }
    // one step from goal (treat edges as undirected for tree)
    const n2=q2.shift(); order2.push(n2);
    // neighbors of n2: its children + parent (find parent by searching parent1/parent2 maps)
    // To get parent, we need function to find parent quickly - construct parent map once
    // For simplicity, derive neighbors by scanning whole tree relationships
    const neighbors = [];
    // children
    for(const c of n2.children) neighbors.push(c);
    // parent: find node that contains n2 in children
    function findParent(root, target){
      let p=null;
      function walk(n){
        for(const c of n.children){
          if(c===target){ p=n; return; }
          walk(c);
          if(p) return;
        }
      }
      walk(root); return p;
    }
    const pOfN2 = findParent(root, n2);
    if(pOfN2) neighbors.push(pOfN2);
    for(const nb of neighbors){
      if(!vis2.has(nb)){ vis2.add(nb); parent2.set(nb,n2); q2.push(nb); }
    }
    // check intersection
    for(const node of vis1){
      if(vis2.has(node)){
        return {found:true, meetingNode:node, targetFound:target, orderFromStart:order1, orderFromGoal:order2};
      }
    }
  }
  return {found:false, orderFromStart:order1, orderFromGoal:order2};
}


// ---------- Animate an ordered visit list ----------
async function animateOrder(nodes, extraMapper=null){
  const logEl=document.getElementById('log'); logEl.innerHTML='';
  const stepsCountEl=document.getElementById('stepsCount');
  for(let i=0;i<nodes.length;i++){
    const entry = nodes[i];
    const node = entry && entry.node ? entry.node : entry;
    drawTree(node,null);
    await sleep(speed);
    const div=document.createElement('div');
    if(entry && entry.cost!==undefined) div.textContent=(i+1)+'. '+node.label+' (cumCost='+entry.cost+')';
    else div.textContent=(i+1)+'. '+node.label;
    logEl.appendChild(div);
  }
  stepsCountEl.textContent = nodes.length;
}

// ---------- Start Search orchestration ----------
async function startSearch(){
  const alg=document.getElementById('alg').value;
  const query=document.getElementById('query').value.trim();
  let limit=parseInt(document.getElementById('limit').value);
  if(!query) return alert('Enter a student name');

  // disable start button while running
  const startBtn = document.getElementById('startBtn');
  startBtn.disabled = true;

  const logEl=document.getElementById('log'); logEl.innerHTML='';
  const stepsCountEl=document.getElementById('stepsCount');
  let foundNode=null;

  if(alg==='DLS') {
    window.showCosts = false;
    const res=await DLS(tree,query,limit,[],0,[]);
    foundNode=res.found;
    generateExplanation('DLS',query,limit,res.trace,null,foundNode);
    const steps=res.trace.filter(t=>t.action==='visit').map(t=>({label:t.node}));
    // display steps already done inside DLS
  }
  else if(alg==='IDDFS') {
    window.showCosts = false;
    const maxDepth=Math.max(limit);
    const res=await IDDFS(tree,query,maxDepth,[]);
    foundNode=res.found;
    generateExplanation('IDDFS',query,maxDepth,null,res.allTraces,foundNode,res.finalDepth);
  }
  else if(alg==='DFS') {
    window.showCosts = false;
    const order = DFS_Order(tree,query);
    // animate nodes
    await animateOrder(order);
    foundNode = findNodeByLabel(tree, query);
    generateExplanation('DFS', query, null, null, null, foundNode);
  }
  else if(alg==='BFS') {
    window.showCosts = false;
    const order = BFS_Order(tree,query);
    await animateOrder(order);
    foundNode = findNodeByLabel(tree, query);
    generateExplanation('BFS', query, null, null, null, foundNode);
  }
  else if(alg==='UCS') {
    window.showCosts = true;
    const order = UCS_Order(tree,query);
    // animate showing cumulative costs
    const displayOrder = order.map(o=>({node:o.node, cost:o.cost}));
    await animateOrder(displayOrder);
    // find first where node label matches query
    const match = order.find(o=>o.node.label.toLowerCase().includes(query.toLowerCase()));
    foundNode = match ? match.node : null;
    generateExplanation('UCS', query, null, null, null, foundNode);
  }
  else if(alg==='Bidirectional') {
    window.showCosts = false;
    // run bidirectional and animate both frontiers sequentially
    const res = Bidirectional_Order(tree, query);
    if(res.found){
      // animate interleaved orders
      const maxLen = Math.max(res.orderFromStart.length, res.orderFromGoal.length);
      const logEl=document.getElementById('log'); logEl.innerHTML='';
      for(let i=0;i<maxLen;i++){
        if(i < res.orderFromStart.length){
          drawTree(res.orderFromStart[i], null, 'From Start');
          await sleep(speed);
          const div=document.createElement('div');
          div.textContent = (i+1)+'. [S] '+res.orderFromStart[i].label;
          logEl.appendChild(div);
        }
        if(i < res.orderFromGoal.length){
          drawTree(res.orderFromGoal[i], null, 'From Goal');
          await sleep(speed);
          const div=document.createElement('div');
          div.textContent = (i+1)+'. [G] '+res.orderFromGoal[i].label;
          logEl.appendChild(div);
        }
      }
      foundNode = res.targetFound;
    } else {
      // Animate what we have
      await animateOrder(res.orderFromStart.concat(res.orderFromGoal));
      foundNode = null;
    }
    generateExplanation('Bidirectional', query, null, null, null, foundNode);
  }

  // finalize UI
  const badgeEl=document.getElementById('resultBadge');
  badgeEl.classList.remove('d-none','bg-success','bg-danger');
  if(foundNode){
    badgeEl.textContent='‚úì Found: '+foundNode.label;
    badgeEl.classList.add('bg-success');
    drawTree(foundNode,foundNode);
  } else {
    badgeEl.textContent='‚úó Not Found';
    badgeEl.classList.add('bg-danger');
  }

  // complexity panel
  const complexityEl=document.getElementById('complexity');
  if(alg==='DLS') complexityEl.innerHTML='DLS: Time O(b<sup>l</sup>), Space O(l)';
  else if(alg==='IDDFS') complexityEl.innerHTML='IDDFS: Time O(b<sup>d</sup>), Space O(d)';
  else if(alg==='DFS') complexityEl.innerHTML='DFS: Time O(b<sup>d</sup>), Space O(d)';
  else if(alg==='BFS') complexityEl.innerHTML='BFS: Time O(b<sup>d</sup>), Space O(b<sup>d</sup>)';
  else if(alg==='UCS') complexityEl.innerHTML='UCS: Time O(b<sup>c*</sup>), Space O(b<sup>c*</sup>) (c* = cost of optimal solution)';
  else if(alg==='Bidirectional') complexityEl.innerHTML='Bidirectional (BFS): Time O(b<sup>d/2</sup> + b<sup>d/2</sup>), Space O(b<sup>d/2</sup>)';

  startBtn.disabled = false;
}

// ---------- All students (collect from tree) ----------
const allEl=document.getElementById('allStudents');
function collectStudents(node) {
  if(node.label.startsWith('Student')) {
    const div=document.createElement('div'); 
    div.className='student';
    div.textContent=node.label;
    allEl.appendChild(div);
  }
  node.children.forEach(c => collectStudents(c));
}
collectStudents(tree);

// ---------- Reset ----------
function resetTree(){
  drawTree();
  document.getElementById('log').innerHTML='';
  document.getElementById('stepsCount').textContent='0';
  document.getElementById('complexity').innerHTML='';
  document.getElementById('explanation').innerHTML='<span class="text-muted">Run a search to see a detailed explanation of what the algorithm did!</span>';
  const badgeEl=document.getElementById('resultBadge');
  badgeEl.classList.add('d-none');
  badgeEl.classList.remove('bg-success','bg-danger');
  const startBtn = document.getElementById('startBtn');
  startBtn.disabled = false;
}

// ---------- Explanation generator (extended) ----------
function generateExplanation(alg,query,limit,trace,allTraces,foundNode,finalDepth){
  const expEl=document.getElementById('explanation');
  let html='';
  if(alg==='DLS'){
    html+=`<h6>üîç DLS Search for "${query}" with depth limit ${limit}</h6>`;
    html+=`<div class="mb-2"><strong>Algorithm Started:</strong> Beginning Depth-Limited Search from the root node.</div>`;
    const visits=trace.filter(t=>t.action==='visit');
    const limitHits=trace.filter(t=>t.action==='limit_reached');
    const backtracks=trace.filter(t=>t.action==='backtrack');
    html+=`<div class="mb-2">`;
    html+=`<strong>What happened:</strong><br>`;
    html+=`‚Ä¢ Visited <strong>${visits.length}</strong> nodes total<br>`;
    html+=`‚Ä¢ Hit depth limit <strong>${limitHits.length}</strong> times<br>`;
    html+=`‚Ä¢ Backtracked <strong>${backtracks.length}</strong> times<br>`;
    html+=`</div>`;
    if(foundNode){
      const foundTrace=trace.find(t=>t.action==='found');
      html+=`<div class="alert alert-success mb-2"><strong>‚úÖ SUCCESS!</strong> Found "${foundNode.label}" at depth ${foundTrace.depth}.</div>`;
    } else {
      html+=`<div class="alert alert-danger mb-2"><strong>‚ùå NOT FOUND</strong> within depth limit ${limit}.</div>`;
    }
  }
  else if(alg==='IDDFS'){
    html+=`<h6>üîÑ IDDFS Search for "${query}" up to depth ${limit}</h6>`;
    const totalVisits=allTraces.reduce((sum,at)=>sum+at.trace.filter(t=>t.action==='visit').length,0);
    html+=`<div class="mb-2">Tried increasing depth limits. Total visited across iterations: <strong>${totalVisits}</strong>.</div>`;
    if(foundNode) html+=`<div class="alert alert-success mb-2"><strong>‚úÖ SUCCESS!</strong> Found "${foundNode.label}".</div>`;
    else html+=`<div class="alert alert-danger mb-2"><strong>‚ùå NOT FOUND</strong> up to max depth.</div>`;
  }
  else if(alg==='DFS'){
    html+=`<h6>üîé DFS (Depth-First Search) for "${query}"</h6>`;
    html+=`<div class="mb-2">DFS explores by going deep along each branch before backtracking. It's memory efficient but not guaranteed to find shortest path.</div>`;
    if(foundNode) html+=`<div class="alert alert-success mb-2"><strong>‚úÖ Found:</strong> ${foundNode.label}</div>`;
    else html+=`<div class="alert alert-danger mb-2"><strong>‚ùå Not Found</strong></div>`;
  }
  else if(alg==='BFS'){
    html+=`<h6>üìè BFS (Breadth-First Search) for "${query}"</h6>`;
    html+=`<div class="mb-2">BFS visits nodes level-by-level; it finds the shallowest solution (shortest number of edges) but can use a lot of memory.</div>`;
    if(foundNode) html+=`<div class="alert alert-success mb-2"><strong>‚úÖ Found:</strong> ${foundNode.label}</div>`;
    else html+=`<div class="alert alert-danger mb-2"><strong>‚ùå Not Found</strong></div>`;
  }
  else if(alg==='UCS'){
    html+=`<h6>üí≤ Uniform-Cost Search for "${query}"</h6>`;
    html+=`<div class="mb-2">UCS expands the lowest cumulative cost node first (optimal for path cost). Edge costs are shown near edges for demonstration.</div>`;
    if(foundNode) html+=`<div class="alert alert-success mb-2"><strong>‚úÖ Found (cost-aware):</strong> ${foundNode.label}</div>`;
    else html+=`<div class="alert alert-danger mb-2"><strong>‚ùå Not Found</strong></div>`;
  }
  else if(alg==='Bidirectional'){
    html+=`<h6>‚ÜîÔ∏è Bidirectional Search for "${query}"</h6>`;
    html+=`<div class="mb-2">Bidirectional search runs two simultaneous BFS from start and goal and meets in the middle ‚Äî much faster in big trees.</div>`;
    if(foundNode) html+=`<div class="alert alert-success mb-2"><strong>‚úÖ Meeting node:</strong> ${foundNode.label}</div>`;
    else html+=`<div class="alert alert-danger mb-2"><strong>‚ùå Not Found</strong></div>`;
  }
  expEl.innerHTML=html;
}

drawTree();
</script>
</body>
</html>
